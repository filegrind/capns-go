package bifaci

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/filegrind/capns-go/cap"
	"github.com/filegrind/capns-go/urn"
	cborlib "github.com/fxamacker/cbor/v2"
)

const testManifest = `{"name":"TestPlugin","version":"1.0.0","description":"Test plugin","caps":[{"urn":"cap:in=\"media:void\";op=test;out=\"media:void\"","title":"Test","command":"test"}]}`

// Mock emitter that captures emitted data for testing
type mockStreamEmitter struct {
	emittedData [][]byte
}

func (m *mockStreamEmitter) EmitCbor(value interface{}) error {
	// CBOR-encode the value
	cborPayload, err := cborlib.Marshal(value)
	if err != nil {
		return err
	}
	m.emittedData = append(m.emittedData, cborPayload)
	return nil
}

func (m *mockStreamEmitter) EmitLog(level, message string) {
	// No-op for tests
}

// Helper to get all emitted data as single concatenated bytes
func (m *mockStreamEmitter) GetAllData() []byte {
	var result []byte
	for _, chunk := range m.emittedData {
		result = append(result, chunk...)
	}
	return result
}

// bytesToFrameChannel converts a byte payload to a frame channel for testing.
// Sends: STREAM_START → CHUNK → STREAM_END → END
func bytesToFrameChannel(payload []byte) <-chan Frame {
	ch := make(chan Frame, 4)
	go func() {
		defer close(ch)
		requestID := NewMessageIdDefault()
		streamID := "test-arg"
		mediaUrn := "media:bytes"

		// STREAM_START
		ch <- *NewStreamStart(requestID, streamID, mediaUrn)

		// CHUNK (if payload is not empty)
		if len(payload) > 0 {
			chunkIndex := uint64(0)
			checksum := ComputeChecksum(payload)
			ch <- *NewChunk(requestID, streamID, 0, payload, chunkIndex, checksum)
		}

		// STREAM_END
		ch <- *NewStreamEnd(requestID, streamID)

		// END
		ch <- *NewEnd(requestID, nil)
	}()
	return ch
}

// TEST248: Test register handler by exact cap URN and find it by the same URN
func TestRegisterAndFindHandler(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=test;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("result")
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=test;out="media:void"`)
	if handler == nil {
		t.Fatal("Expected to find handler, got nil")
	}
}

// TEST249: Test register_raw handler works with bytes directly without deserialization
func TestRawHandler(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=raw;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			// Collect first arg and echo it
			payload, err := CollectFirstArg(frames)
			if err != nil {
				return err
			}
			return emitter.EmitCbor(payload)
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=raw;out="media:void"`)
	if handler == nil {
		t.Fatal("Expected to find handler")
	}

	emitter := &mockStreamEmitter{}
	peer := &noPeerInvoker{}
	err = handler(bytesToFrameChannel([]byte("echo this")), emitter, peer)
	if err != nil {
		t.Fatalf("Handler failed: %v", err)
	}
	// Decode CBOR
	var result []byte
	if err := cborlib.Unmarshal(emitter.GetAllData(), &result); err != nil {
		t.Fatalf("Failed to decode result: %v", err)
	}
	if string(result) != "echo this" {
		t.Errorf("Expected 'echo this', got %s", string(result))
	}
}

// TEST250: Test register typed handler deserializes JSON and executes correctly
func TestTypedHandlerDeserialization(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=test;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			payload, err := CollectFirstArg(frames)
			if err != nil {
				return err
			}
			var req map[string]interface{}
			if err := json.Unmarshal(payload, &req); err != nil {
				return err
			}
			value := req["key"]
			if value == nil {
				return emitter.EmitCbor("missing")
			}
			return emitter.EmitCbor(value.(string))
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=test;out="media:void"`)
	emitter := &mockStreamEmitter{}
	peer := &noPeerInvoker{}
	err = handler(bytesToFrameChannel([]byte(`{"key":"hello"}`)), emitter, peer)
	if err != nil {
		t.Fatalf("Handler failed: %v", err)
	}
	var result string
	if err := cborlib.Unmarshal(emitter.GetAllData(), &result); err != nil {
		t.Fatalf("Failed to decode: %v", err)
	}
	if result != "hello" {
		t.Errorf("Expected 'hello', got %s", result)
	}
}

// TEST251: Test typed handler returns error for invalid JSON input
func TestTypedHandlerRejectsInvalidJSON(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=test;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			payload, err := CollectFirstArg(frames)
			if err != nil {
				return err
			}
			var req map[string]interface{}
			if err := json.Unmarshal(payload, &req); err != nil {
				return err
			}
			return emitter.EmitCbor([]byte{})
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=test;out="media:void"`)
	emitter := &mockStreamEmitter{}
	peer := &noPeerInvoker{}
	err = handler(bytesToFrameChannel([]byte("not json {{{{")), emitter, peer)
	if err == nil {
		t.Fatal("Expected error for invalid JSON, got nil")
	}
}

// TEST252: Test find_handler returns None for unregistered cap URNs
func TestFindHandlerUnknownCap(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	handler := runtime.FindHandler(`cap:in="media:void";op=nonexistent;out="media:void"`)
	if handler != nil {
		t.Fatal("Expected nil for unknown cap, got handler")
	}
}

// TEST253: Test handler function can be cloned via Arc and sent across threads (Send + Sync)
func TestHandlerIsSendSync(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=threaded;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("done")
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=threaded;out="media:void"`)
	if handler == nil {
		t.Fatal("Expected handler")
	}

	// Test that handler can be called from goroutine
	doneCh := make(chan bool)
	go func() {
		emitter := &mockStreamEmitter{}
		peer := &noPeerInvoker{}
		err := handler(bytesToFrameChannel([]byte("{}")), emitter, peer)
		if err != nil {
			t.Errorf("Handler failed: %v", err)
		}
		var result string
		if err := cborlib.Unmarshal(emitter.GetAllData(), &result); err != nil {
			t.Errorf("Failed to decode: %v", err)
		}
		if result != "done" {
			t.Errorf("Expected 'done', got %s", result)
		}
		doneCh <- true
	}()
	<-doneCh
}

// TEST254: Test NoPeerInvoker always returns PeerRequest error regardless of arguments
func TestNoPeerInvoker(t *testing.T) {
	peer := &noPeerInvoker{}
	_, err := peer.Invoke(`cap:in="media:void";op=test;out="media:void"`, []cap.CapArgumentValue{})
	if err == nil {
		t.Fatal("Expected error from NoPeerInvoker, got nil")
	}
	if err.Error() != "peer invocation not supported in this context" {
		t.Errorf("Unexpected error message: %s", err.Error())
	}
}

// TEST255: Test NoPeerInvoker returns error even with valid arguments
func TestNoPeerInvokerWithArguments(t *testing.T) {
	peer := &noPeerInvoker{}
	args := []cap.CapArgumentValue{
		cap.NewCapArgumentValueFromStr("media:test", "value"),
	}
	_, err := peer.Invoke(`cap:in="media:void";op=test;out="media:void"`, args)
	if err == nil {
		t.Fatal("Expected error from NoPeerInvoker with arguments")
	}
}

// TEST256: Test NewPluginRuntime stores manifest data and parses when valid
func TestNewPluginRuntimeWithValidJSON(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	if len(runtime.manifestData) == 0 {
		t.Fatal("Expected manifest data to be stored")
	}
	if runtime.manifest == nil {
		t.Fatal("Expected manifest to be parsed")
	}
}

// TEST257: Test NewPluginRuntime with invalid JSON still creates runtime (manifest is None)
func TestNewPluginRuntimeWithInvalidJSON(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte("not json"))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	if len(runtime.manifestData) == 0 {
		t.Fatal("Expected manifest data to be stored even if invalid")
	}
	if runtime.manifest != nil {
		t.Fatal("Expected manifest to be nil for invalid JSON")
	}
}

// TEST258: Test NewPluginRuntimeWithManifest creates runtime with valid manifest data
func TestNewPluginRuntimeWithManifestStruct(t *testing.T) {
	var manifest CapManifest
	if err := json.Unmarshal([]byte(testManifest), &manifest); err != nil {
		t.Fatalf("Failed to parse test manifest: %v", err)
	}

	runtime, err := NewPluginRuntimeWithManifest(&manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	if len(runtime.manifestData) == 0 {
		t.Fatal("Expected manifest data")
	}
	if runtime.manifest == nil {
		t.Fatal("Expected manifest to be set")
	}
}

// TEST259: Test extract_effective_payload with non-CBOR content_type returns raw payload unchanged
func TestExtractEffectivePayloadNonCBOR(t *testing.T) {
	payload := []byte("raw data")
	result, err := extractEffectivePayload(payload, "application/json", `cap:in="media:void";op=test;out="media:void"`)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if string(result) != string(payload) {
		t.Errorf("Expected unchanged payload, got %s", string(result))
	}
}

// TEST260: Test extract_effective_payload with empty content_type returns raw payload unchanged
func TestExtractEffectivePayloadNoContentType(t *testing.T) {
	payload := []byte("raw data")
	result, err := extractEffectivePayload(payload, "", `cap:in="media:void";op=test;out="media:void"`)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if string(result) != string(payload) {
		t.Errorf("Expected unchanged payload")
	}
}

// TEST261: Test extract_effective_payload with CBOR content extracts matching argument value
func TestExtractEffectivePayloadCBORMatch(t *testing.T) {
	// For now, simplified implementation returns raw payload
	// Full CBOR argument extraction will be implemented when needed
	payload := []byte("test payload")
	result, err := extractEffectivePayload(payload, "application/cbor", `cap:in="media:string;textable;form=scalar";op=test;out="media:void"`)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	// Currently returns raw payload - this will be enhanced
	if string(result) != string(payload) {
		t.Errorf("Expected payload to be returned")
	}
}

// TEST262: Test extract_effective_payload with CBOR content fails when no argument matches expected input
func TestExtractEffectivePayloadCBORNoMatch(t *testing.T) {
	// This test will be meaningful when full CBOR decoding is implemented
	// For now, simplified version returns raw payload
	payload := []byte("test")
	_, err := extractEffectivePayload(payload, "application/cbor", `cap:in="media:string;textable;form=scalar";op=test;out="media:void"`)
	// Currently doesn't fail - will when CBOR parsing is added
	if err != nil {
		t.Logf("Note: Error handling to be enhanced with full CBOR support: %v", err)
	}
}

// TEST263: Test extract_effective_payload with invalid CBOR bytes returns deserialization error
func TestExtractEffectivePayloadInvalidCBOR(t *testing.T) {
	// Will be meaningful when CBOR decoding is implemented
	payload := []byte("not cbor")
	_, err := extractEffectivePayload(payload, "application/cbor", `cap:in="media:void";op=test;out="media:void"`)
	// Currently returns raw payload - will fail when CBOR parsing added
	if err != nil {
		t.Logf("Note: Will properly validate CBOR when parsing is added: %v", err)
	}
}

// TEST264: Test extract_effective_payload with CBOR non-array (e.g. map) returns error
func TestExtractEffectivePayloadCBORNotArray(t *testing.T) {
	// Will be meaningful when CBOR decoding is implemented
	payload := []byte("{}")
	_, err := extractEffectivePayload(payload, "application/cbor", `cap:in="media:void";op=test;out="media:void"`)
	// Currently returns raw - will validate structure when parsing added
	if err != nil {
		t.Logf("Note: Structure validation to be added: %v", err)
	}
}

// TEST265: Test extract_effective_payload with invalid cap URN returns CapUrn error
func TestExtractEffectivePayloadInvalidCapUrn(t *testing.T) {
	payload := []byte("test")
	_, err := extractEffectivePayload(payload, "application/cbor", "not-a-cap-urn")
	if err == nil {
		t.Fatal("Expected error for invalid cap URN")
	}
}

// TEST270: Test registering multiple handlers for different caps and finding each independently
func TestMultipleHandlers(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=alpha;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("a")
		})
	runtime.Register(`cap:in="media:void";op=beta;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("b")
		})
	runtime.Register(`cap:in="media:void";op=gamma;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("g")
		})

	peer := &noPeerInvoker{}

	emitterA := &mockStreamEmitter{}
	hAlpha := runtime.FindHandler(`cap:in="media:void";op=alpha;out="media:void"`)
	_ = hAlpha(bytesToFrameChannel([]byte{}), emitterA, peer)
	var resultA string
	cborlib.Unmarshal(emitterA.GetAllData(), &resultA)
	if resultA != "a" {
		t.Errorf("Expected 'a', got %s", resultA)
	}

	emitterB := &mockStreamEmitter{}
	hBeta := runtime.FindHandler(`cap:in="media:void";op=beta;out="media:void"`)
	_ = hBeta(bytesToFrameChannel([]byte{}), emitterB, peer)
	var resultB string
	cborlib.Unmarshal(emitterB.GetAllData(), &resultB)
	if resultB != "b" {
		t.Errorf("Expected 'b', got %s", resultB)
	}

	emitterG := &mockStreamEmitter{}
	hGamma := runtime.FindHandler(`cap:in="media:void";op=gamma;out="media:void"`)
	_ = hGamma(bytesToFrameChannel([]byte{}), emitterG, peer)
	var resultG string
	cborlib.Unmarshal(emitterG.GetAllData(), &resultG)
	if resultG != "g" {
		t.Errorf("Expected 'g', got %s", resultG)
	}
}

// TEST271: Test handler replacing an existing registration for the same cap URN
func TestHandlerReplacement(t *testing.T) {
	runtime, err := NewPluginRuntime([]byte(testManifest))
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	runtime.Register(`cap:in="media:void";op=test;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("first")
		})
	runtime.Register(`cap:in="media:void";op=test;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			return emitter.EmitCbor("second")
		})

	handler := runtime.FindHandler(`cap:in="media:void";op=test;out="media:void"`)
	emitter := &mockStreamEmitter{}
	peer := &noPeerInvoker{}
	_ = handler(bytesToFrameChannel([]byte{}), emitter, peer)
	var result string
	cborlib.Unmarshal(emitter.GetAllData(), &result)
	if result != "second" {
		t.Errorf("Expected 'second' (later registration), got %s", result)
	}
}

// TEST272: Test extract_effective_payload CBOR with multiple arguments selects the correct one
func TestExtractEffectivePayloadMultipleArgs(t *testing.T) {
	// Will be meaningful when full CBOR argument parsing is implemented
	payload := []byte("test payload")
	result, err := extractEffectivePayload(payload, "application/cbor", `cap:in="media:model-spec;textable;form=scalar";op=infer;out="media:void"`)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	// Currently returns raw - will select correct argument when CBOR parsing added
	if len(result) == 0 {
		t.Error("Expected non-empty result")
	}
}

// TEST273: Test extract_effective_payload with binary data in CBOR value (not just text)
func TestExtractEffectivePayloadBinaryValue(t *testing.T) {
	// Will be meaningful when CBOR binary handling is implemented
	binaryData := make([]byte, 256)
	for i := 0; i < 256; i++ {
		binaryData[i] = byte(i)
	}
	result, err := extractEffectivePayload(binaryData, "application/cbor", `cap:in="media:pdf;bytes";op=process;out="media:void"`)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	// Binary data should roundtrip
	if len(result) != len(binaryData) {
		t.Errorf("Expected binary data length %d, got %d", len(binaryData), len(result))
	}
}

// Helper function to create runtime errors (for TEST268)
func NewPluginRuntimeError(errorType, message string) error {
	return &PluginRuntimeError{
		Type:    errorType,
		Message: message,
	}
}

type PluginRuntimeError struct {
	Type    string
	Message string
}

func (e *PluginRuntimeError) Error() string {
	return e.Type + ": " + e.Message
}

// Helper to create test caps for file-path tests
func createTestCap(urnStr, title, command string, args []cap.CapArg) *cap.Cap {
	urn, err := urn.NewCapUrnFromString(urnStr)
	if err != nil {
		panic(fmt.Sprintf("Invalid cap URN: %v", err))
	}
	return &cap.Cap{
		Urn:     urn,
		Title:   title,
		Command: command,
		Args:    args,
	}
}

// Helper to create cap.ArgSource with stdin
func stdinSource(mediaUrn string) cap.ArgSource {
	return cap.ArgSource{Stdin: &mediaUrn}
}

// Helper to create cap.ArgSource with position
func positionSource(pos int) cap.ArgSource {
	return cap.ArgSource{Position: &pos}
}

// Helper to create cap.ArgSource with CLI flag
func cliFlagSource(flag string) cap.ArgSource {
	return cap.ArgSource{CliFlag: &flag}
}

// Helper to create test manifest
func createTestManifest(name, version, description string, caps []*cap.Cap) *CapManifest {
	capSlice := make([]cap.Cap, len(caps))
	for i, cap := range caps {
		capSlice[i] = *cap
	}
	return &CapManifest{
		Name:        name,
		Version:     version,
		Description: description,
		Caps:        capSlice,
	}
}

// TEST336: Single file-path arg with stdin source reads file and passes bytes to handler
func Test336FilePathReadsFilePassesBytes(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test336_input.pdf")
	if err := os.WriteFile(tempFile, []byte("PDF binary content 336"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process PDF",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Track what handler receives
	var receivedPayload []byte
	runtime.Register(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			payload, err := CollectFirstArg(frames)
			if err != nil {
				return err
			}
			receivedPayload = payload
			return emitter.EmitCbor("processed")
		},
	)

	// Simulate CLI invocation
	cliArgs := []string{tempFile}
	rawPayload, err := runtime.buildPayloadFromCLI(&manifest.Caps[0], cliArgs)
	if err != nil {
		t.Fatalf("Failed to build payload: %v", err)
	}

	// Extract effective payload
	payload, err := extractEffectivePayload(rawPayload, "application/cbor", manifest.Caps[0].UrnString())
	if err != nil {
		t.Fatalf("Failed to extract payload: %v", err)
	}

	handler := runtime.FindHandler(manifest.Caps[0].UrnString())
	emitter := &mockStreamEmitter{}
	peerInvoker := &noPeerInvoker{}
	err = handler(bytesToFrameChannel(payload), emitter, peerInvoker)
	if err != nil {
		t.Fatalf("Handler failed: %v", err)
	}

	// Verify handler received file bytes, not file path
	if string(receivedPayload) != "PDF binary content 336" {
		t.Errorf("Expected handler to receive file bytes, got: %s", string(receivedPayload))
	}
	var result string
	cborlib.Unmarshal(emitter.GetAllData(), &result)
	if result != "processed" {
		t.Errorf("Expected 'processed', got: %s", result)
	}
}

// TEST337: file-path arg without stdin source passes path as string (no conversion)
func Test337FilePathWithoutStdinPassesString(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test337_input.txt")
	if err := os.WriteFile(tempFile, []byte("content"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:void";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					positionSource(0), // NO stdin source!
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Should get file PATH as string, not file CONTENTS
	valueStr := string(result)
	if !strings.Contains(valueStr, "test337_input.txt") {
		t.Errorf("Expected file path string containing 'test337_input.txt', got: %s", valueStr)
	}
}

// TEST338: file-path arg reads file via --file CLI flag
func Test338FilePathViaCliFlag(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test338.pdf")
	if err := os.WriteFile(tempFile, []byte("PDF via flag 338"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					cliFlagSource("--file"),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"--file", tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if string(result) != "PDF via flag 338" {
		t.Errorf("Expected 'PDF via flag 338', got: %s", string(result))
	}
}

// TEST339: file-path-array reads multiple files with glob pattern
func Test339FilePathArrayGlobExpansion(t *testing.T) {
	tempDir := filepath.Join(t.TempDir(), "test339")
	if err := os.MkdirAll(tempDir, 0755); err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	file1 := filepath.Join(tempDir, "doc1.txt")
	file2 := filepath.Join(tempDir, "doc2.txt")
	if err := os.WriteFile(file1, []byte("content1"), 0644); err != nil {
		t.Fatalf("Failed to create file1: %v", err)
	}
	if err := os.WriteFile(file2, []byte("content2"), 0644); err != nil {
		t.Fatalf("Failed to create file2: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Batch",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Pass glob pattern as JSON array
	pattern := filepath.Join(tempDir, "*.txt")
	pathsJSON, _ := json.Marshal([]string{pattern})

	cliArgs := []string{string(pathsJSON)}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Decode CBOR array
	var filesArray [][]byte
	if err := cborlib.Unmarshal(result, &filesArray); err != nil {
		t.Fatalf("Failed to decode CBOR array: %v", err)
	}

	if len(filesArray) != 2 {
		t.Errorf("Expected 2 files, got %d", len(filesArray))
	}

	// Verify contents (order may vary, so check both are present)
	contents := make(map[string]bool)
	for _, data := range filesArray {
		contents[string(data)] = true
	}
	if !contents["content1"] || !contents["content2"] {
		t.Error("Expected both content1 and content2 in results")
	}
}

// TEST340: File not found error provides clear message
func Test340FileNotFoundClearError(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"/nonexistent/file.pdf"}
	_, err = runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)

	if err == nil {
		t.Fatal("Expected error when file doesn't exist")
	}
	errMsg := err.Error()
	if !strings.Contains(errMsg, "/nonexistent/file.pdf") {
		t.Errorf("Error should mention file path: %s", errMsg)
	}
	if !strings.Contains(errMsg, "failed to read file") {
		t.Errorf("Error should be clear about read failure: %s", errMsg)
	}
}

// TEST341: stdin takes precedence over file-path in source order
func Test341StdinPrecedenceOverFilePath(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test341_input.txt")
	if err := os.WriteFile(tempFile, []byte("file content"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	// Stdin source comes BEFORE position source
	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"), // First
					positionSource(0),          // Second
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	stdinData := []byte("stdin content 341")
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, stdinData)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Should get stdin data, not file content (stdin source tried first)
	if string(result) != "stdin content 341" {
		t.Errorf("Expected stdin content, got: %s", string(result))
	}
}

// TEST342: file-path with position 0 reads first positional arg as file
func Test342FilePathPositionZeroReadsFirstArg(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test342.dat")
	if err := os.WriteFile(tempFile, []byte("binary data 342"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if string(result) != "binary data 342" {
		t.Errorf("Expected file content, got: %s", string(result))
	}
}

// TEST343: Non-file-path args are not affected by file reading
func Test343NonFilePathArgsUnaffected(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:void";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:model-spec;textable;form=scalar", // NOT file-path
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:model-spec;textable;form=scalar"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"mlx-community/Llama-3.2-3B-Instruct-4bit"}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Should get the string value, not attempt file read
	if string(result) != "mlx-community/Llama-3.2-3B-Instruct-4bit" {
		t.Errorf("Expected model spec string, got: %s", string(result))
	}
}

// TEST344: file-path-array with invalid JSON fails clearly
func Test344FilePathArrayInvalidJSONFails(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"not a json array"}
	_, err = runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)

	if err == nil {
		t.Fatal("Expected error for invalid JSON")
	}
	errMsg := err.Error()
	if !strings.Contains(errMsg, "failed to parse file-path-array") {
		t.Errorf("Error should mention file-path-array: %s", errMsg)
	}
	if !strings.Contains(errMsg, "expected JSON array") {
		t.Errorf("Error should explain expected format: %s", errMsg)
	}
}

// TEST345: file-path-array with one file failing stops and reports error
func Test345FilePathArrayOneFileMissingFailsHard(t *testing.T) {
	tempDir := t.TempDir()
	file1 := filepath.Join(tempDir, "test345_exists.txt")
	if err := os.WriteFile(file1, []byte("exists"), 0644); err != nil {
		t.Fatalf("Failed to create file1: %v", err)
	}
	file2Path := filepath.Join(tempDir, "test345_missing.txt")

	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Explicitly list both files (one exists, one doesn't)
	pathsJSON, _ := json.Marshal([]string{file1, file2Path})
	cliArgs := []string{string(pathsJSON)}
	_, err = runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)

	if err == nil {
		t.Fatal("Expected error when any file in array is missing")
	}
	errMsg := err.Error()
	if !strings.Contains(errMsg, "test345_missing.txt") {
		t.Errorf("Error should mention the missing file: %s", errMsg)
	}
	if !strings.Contains(errMsg, "failed to read file") {
		t.Errorf("Error should be clear about read failure: %s", errMsg)
	}
}

// TEST346: Large file (1MB) reads successfully
func Test346LargeFileReadsSuccessfully(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test346_large.bin")
	largeData := make([]byte, 1_000_000)
	for i := range largeData {
		largeData[i] = 42
	}
	if err := os.WriteFile(tempFile, largeData, 0644); err != nil {
		t.Fatalf("Failed to create large file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if len(result) != 1_000_000 {
		t.Errorf("Expected 1MB file, got %d bytes", len(result))
	}
}

// TEST347: Empty file reads as empty bytes
func Test347EmptyFileReadsAsEmptyBytes(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test347_empty.txt")
	if err := os.WriteFile(tempFile, []byte{}, 0644); err != nil {
		t.Fatalf("Failed to create empty file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if len(result) != 0 {
		t.Errorf("Expected empty bytes, got %d bytes", len(result))
	}
}

// TEST348: file-path conversion respects source order
func Test348FilePathConversionRespectsSourceOrder(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test348.txt")
	if err := os.WriteFile(tempFile, []byte("file content 348"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	// Position source BEFORE stdin source
	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					positionSource(0),          // First
					stdinSource("media:bytes"), // Second
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	stdinData := []byte("stdin content 348")
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, stdinData)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Position source tried first, so file is read
	if string(result) != "file content 348" {
		t.Errorf("Expected file content (position first), got: %s", string(result))
	}
}

// TEST349: file-path arg with multiple sources tries all in order
func Test349FilePathMultipleSourcesFallback(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test349.txt")
	if err := os.WriteFile(tempFile, []byte("content 349"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					cliFlagSource("--file"),    // First (not provided)
					positionSource(0),          // Second (provided)
					stdinSource("media:bytes"), // Third (not used)
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Only provide position arg, no --file flag
	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if string(result) != "content 349" {
		t.Errorf("Expected to fall back to position source, got: %s", string(result))
	}
}

// TEST350: Integration test - full CLI mode invocation with file-path
func Test350FullCLIModeWithFilePathIntegration(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test350_input.pdf")
	testContent := []byte("PDF file content for integration test")
	if err := os.WriteFile(tempFile, testContent, 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:result;textable"`,
		"Process PDF",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Track what handler receives
	var receivedPayload []byte
	runtime.Register(
		`cap:in="media:pdf;bytes";op=process;out="media:result;textable"`,
		func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
			payload, err := CollectFirstArg(frames)
			if err != nil {
				return err
			}
			receivedPayload = payload
			return emitter.EmitCbor("processed")
		},
	)

	// Simulate full CLI invocation
	cliArgs := []string{tempFile}
	rawPayload, err := runtime.buildPayloadFromCLI(&manifest.Caps[0], cliArgs)
	if err != nil {
		t.Fatalf("Failed to build payload: %v", err)
	}

	// Extract effective payload
	payload, err := extractEffectivePayload(rawPayload, "application/cbor", manifest.Caps[0].UrnString())
	if err != nil {
		t.Fatalf("Failed to extract payload: %v", err)
	}

	handler := runtime.FindHandler(manifest.Caps[0].UrnString())
	emitter := &mockStreamEmitter{}
	peerInvoker := &noPeerInvoker{}
	err = handler(bytesToFrameChannel(payload), emitter, peerInvoker)
	if err != nil {
		t.Fatalf("Handler failed: %v", err)
	}

	// Verify handler received file bytes
	if string(receivedPayload) != string(testContent) {
		t.Errorf("Handler should receive file bytes, not path")
	}
	var result string
	cborlib.Unmarshal(emitter.GetAllData(), &result)
	if result != "processed" {
		t.Errorf("Expected 'processed', got: %s", result)
	}
}

// TEST351: file-path-array with empty array succeeds
func Test351FilePathArrayEmptyArray(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: false, // Not required
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"[]"}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Decode CBOR array
	var filesArray [][]byte
	if err := cborlib.Unmarshal(result, &filesArray); err != nil {
		t.Fatalf("Failed to decode CBOR array: %v", err)
	}

	if len(filesArray) != 0 {
		t.Errorf("Expected empty array, got %d elements", len(filesArray))
	}
}

// TEST352: file permission denied error is clear (Unix-specific, skip on Windows)
func Test352FilePermissionDeniedClearError(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("Skipping permission test on Windows")
	}

	tempFile := filepath.Join(t.TempDir(), "test352_noperm.txt")
	if err := os.WriteFile(tempFile, []byte("content"), 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	// Remove read permissions
	if err := os.Chmod(tempFile, 0000); err != nil {
		t.Fatalf("Failed to change permissions: %v", err)
	}
	defer os.Chmod(tempFile, 0644) // Restore for cleanup

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	_, err = runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)

	if err == nil {
		t.Fatal("Expected error for permission denied")
	}
	if !strings.Contains(err.Error(), "test352_noperm.txt") {
		t.Errorf("Error should mention the file: %s", err.Error())
	}
}

// TEST353: CBOR payload format matches between CLI and CBOR mode
func Test353CBORPayloadFormatConsistency(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:text;textable";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:text;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:text;textable"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{"test value"}
	payload, err := runtime.buildPayloadFromCLI(&manifest.Caps[0], cliArgs)
	if err != nil {
		t.Fatalf("Failed to build payload: %v", err)
	}

	// Decode CBOR payload
	var argsArray []map[string]interface{}
	if err := cborlib.Unmarshal(payload, &argsArray); err != nil {
		t.Fatalf("Failed to decode CBOR: %v", err)
	}

	if len(argsArray) != 1 {
		t.Errorf("Expected 1 argument, got %d", len(argsArray))
	}

	// Verify structure: { media_urn: "...", value: bytes }
	arg := argsArray[0]
	mediaUrn, hasUrn := arg["media_urn"].(string)
	value, hasValue := arg["value"].([]byte)

	if !hasUrn || !hasValue {
		t.Fatal("Expected argument to have media_urn and value fields")
	}

	if mediaUrn != "media:text;textable;form=scalar" {
		t.Errorf("Expected media_urn 'media:text;textable;form=scalar', got: %s", mediaUrn)
	}

	if string(value) != "test value" {
		t.Errorf("Expected value 'test value', got: %s", string(value))
	}
}

// TEST354: Glob pattern with no matches produces empty array
func Test354GlobPatternNoMatchesEmptyArray(t *testing.T) {
	tempDir := t.TempDir()

	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Glob pattern that matches nothing
	pattern := filepath.Join(tempDir, "nonexistent_*.xyz")
	pathsJSON, _ := json.Marshal([]string{pattern})

	cliArgs := []string{string(pathsJSON)}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Decode CBOR array
	var filesArray [][]byte
	if err := cborlib.Unmarshal(result, &filesArray); err != nil {
		t.Fatalf("Failed to decode CBOR array: %v", err)
	}

	if len(filesArray) != 0 {
		t.Errorf("Expected empty array for no matches, got %d elements", len(filesArray))
	}
}

// TEST355: Glob pattern skips directories
func Test355GlobPatternSkipsDirectories(t *testing.T) {
	tempDir := filepath.Join(t.TempDir(), "test355")
	if err := os.MkdirAll(tempDir, 0755); err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	subdir := filepath.Join(tempDir, "subdir")
	if err := os.MkdirAll(subdir, 0755); err != nil {
		t.Fatalf("Failed to create subdir: %v", err)
	}

	file1 := filepath.Join(tempDir, "file1.txt")
	if err := os.WriteFile(file1, []byte("content1"), 0644); err != nil {
		t.Fatalf("Failed to create file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Glob that matches both file and directory
	pattern := filepath.Join(tempDir, "*")
	pathsJSON, _ := json.Marshal([]string{pattern})

	cliArgs := []string{string(pathsJSON)}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Decode CBOR array
	var filesArray [][]byte
	if err := cborlib.Unmarshal(result, &filesArray); err != nil {
		t.Fatalf("Failed to decode CBOR array: %v", err)
	}

	// Should only include the file, not the directory
	if len(filesArray) != 1 {
		t.Errorf("Expected 1 file (not directory), got %d", len(filesArray))
	}

	if string(filesArray[0]) != "content1" {
		t.Errorf("Expected 'content1', got: %s", string(filesArray[0]))
	}
}

// TEST356: Multiple glob patterns combined
func Test356MultipleGlobPatternsCombined(t *testing.T) {
	tempDir := filepath.Join(t.TempDir(), "test356")
	if err := os.MkdirAll(tempDir, 0755); err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	file1 := filepath.Join(tempDir, "doc.txt")
	file2 := filepath.Join(tempDir, "data.json")
	if err := os.WriteFile(file1, []byte("text"), 0644); err != nil {
		t.Fatalf("Failed to create file1: %v", err)
	}
	if err := os.WriteFile(file2, []byte("json"), 0644); err != nil {
		t.Fatalf("Failed to create file2: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Multiple patterns
	pattern1 := filepath.Join(tempDir, "*.txt")
	pattern2 := filepath.Join(tempDir, "*.json")
	pathsJSON, _ := json.Marshal([]string{pattern1, pattern2})

	cliArgs := []string{string(pathsJSON)}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	// Decode CBOR array
	var filesArray [][]byte
	if err := cborlib.Unmarshal(result, &filesArray); err != nil {
		t.Fatalf("Failed to decode CBOR array: %v", err)
	}

	if len(filesArray) != 2 {
		t.Errorf("Expected 2 files from different patterns, got %d", len(filesArray))
	}

	// Collect contents (order may vary)
	contents := make(map[string]bool)
	for _, data := range filesArray {
		contents[string(data)] = true
	}

	if !contents["text"] || !contents["json"] {
		t.Error("Expected both 'text' and 'json' in results")
	}
}

// TEST357: Symlinks are followed when reading files (Unix-specific, skip on Windows)
func Test357SymlinksFollowed(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("Skipping symlink test on Windows")
	}

	tempDir := filepath.Join(t.TempDir(), "test357")
	if err := os.MkdirAll(tempDir, 0755); err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	realFile := filepath.Join(tempDir, "real.txt")
	linkFile := filepath.Join(tempDir, "link.txt")
	if err := os.WriteFile(realFile, []byte("real content"), 0644); err != nil {
		t.Fatalf("Failed to create real file: %v", err)
	}
	if err := os.Symlink(realFile, linkFile); err != nil {
		t.Fatalf("Failed to create symlink: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{linkFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if string(result) != "real content" {
		t.Errorf("Expected symlink to be followed, got: %s", string(result))
	}
}

// TEST358: Binary file with non-UTF8 data reads correctly
func Test358BinaryFileNonUTF8(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test358.bin")
	binaryData := []byte{0xFF, 0xFE, 0x00, 0x01, 0x80, 0x7F, 0xAB, 0xCD}
	if err := os.WriteFile(tempFile, binaryData, 0644); err != nil {
		t.Fatalf("Failed to create binary file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:bytes";op=test;out="media:void"`,
		"Test",
		"test",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}
	result, err := runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)
	if err != nil {
		t.Fatalf("Failed to extract arg: %v", err)
	}

	if len(result) != len(binaryData) {
		t.Errorf("Expected %d bytes, got %d", len(binaryData), len(result))
	}
	for i := range binaryData {
		if result[i] != binaryData[i] {
			t.Errorf("Binary data mismatch at index %d: expected %d, got %d", i, binaryData[i], result[i])
		}
	}
}

// TEST359: Invalid glob pattern fails with clear error
func Test359InvalidGlobPatternFails(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=batch;out="media:void"`,
		"Test",
		"batch",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=list",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Invalid glob pattern (unclosed bracket)
	pathsJSON, _ := json.Marshal([]string{"[invalid"})

	cliArgs := []string{string(pathsJSON)}
	_, err = runtime.extractArgValue(&manifest.Caps[0].Args[0], cliArgs, nil)

	if err == nil {
		t.Fatal("Expected error for invalid glob pattern")
	}
	if !strings.Contains(err.Error(), "invalid glob pattern") {
		t.Errorf("Error should mention invalid glob: %s", err.Error())
	}
}

// TEST360: Extract effective payload handles file-path data correctly
func Test360ExtractEffectivePayloadWithFileData(t *testing.T) {
	tempFile := filepath.Join(t.TempDir(), "test360.pdf")
	pdfContent := []byte("PDF content for extraction test")
	if err := os.WriteFile(tempFile, pdfContent, 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	cliArgs := []string{tempFile}

	// Build CBOR payload (what buildPayloadFromCLI does)
	rawPayload, err := runtime.buildPayloadFromCLI(&manifest.Caps[0], cliArgs)
	if err != nil {
		t.Fatalf("Failed to build payload: %v", err)
	}

	// Extract effective payload (what runCLIMode does)
	effective, err := extractEffectivePayload(rawPayload, "application/cbor", manifest.Caps[0].UrnString())
	if err != nil {
		t.Fatalf("Failed to extract effective payload: %v", err)
	}

	// The effective payload should be the raw PDF bytes
	if string(effective) != string(pdfContent) {
		t.Errorf("extract_effective_payload should extract file bytes, got: %s", string(effective))
	}
}

// TEST361: CLI mode with file path - pass file path as command-line argument
func Test361CLIModeFilePath(t *testing.T) {
	tempFile := filepath.Join(os.TempDir(), "test361.pdf")
	pdfContent := []byte("PDF content for CLI file path test")
	if err := os.WriteFile(tempFile, pdfContent, 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}
	defer os.Remove(tempFile)

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:file-path;textable;form=scalar",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
					positionSource(0),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// CLI mode: pass file path as positional argument
	cliArgs := []string{tempFile}
	payload, err := runtime.buildPayloadFromCLI(&manifest.Caps[0], cliArgs)
	if err != nil {
		t.Fatalf("Failed to build payload from CLI: %v", err)
	}

	// Verify payload is CBOR array with file-path argument
	var cborVal interface{}
	if err := cborlib.Unmarshal(payload, &cborVal); err != nil {
		t.Fatalf("Failed to unmarshal CBOR: %v", err)
	}

	if _, ok := cborVal.([]interface{}); !ok {
		t.Errorf("CLI mode should produce CBOR array, got: %T", cborVal)
	}
}

// TEST362: CLI mode with binary piped in - pipe binary data via stdin
//
// This test simulates real-world conditions:
// - Pure binary data piped to stdin (NOT CBOR)
// - CLI mode detected (command arg present)
// - cap.Cap accepts stdin source
// - Binary is chunked on-the-fly and accumulated
// - Handler receives complete CBOR payload
func Test362CLIModePipedBinary(t *testing.T) {
	// Simulate large binary being piped (1MB PDF)
	pdfContent := make([]byte, 1_000_000)
	for i := range pdfContent {
		pdfContent[i] = 0xAB
	}

	// Create cap that accepts stdin
	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:pdf;bytes",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Mock stdin with bytes.Reader (simulates piped binary)
	mockStdin := strings.NewReader(string(pdfContent))

	// Build payload from streaming reader (what CLI piped mode does)
	payload, err := runtime.buildPayloadFromStreamingReader(capDef, mockStdin, DefaultLimits().MaxChunk)
	if err != nil {
		t.Fatalf("Failed to build payload from streaming reader: %v", err)
	}

	// Verify payload is CBOR array with correct structure
	var cborVal interface{}
	if err := cborlib.Unmarshal(payload, &cborVal); err != nil {
		t.Fatalf("Failed to unmarshal CBOR: %v", err)
	}

	arr, ok := cborVal.([]interface{})
	if !ok {
		t.Fatalf("Expected CBOR Array, got: %T", cborVal)
	}

	if len(arr) != 1 {
		t.Fatalf("CBOR array should have one argument, got: %d", len(arr))
	}

	argMap, ok := arr[0].(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected Map in CBOR array, got: %T", arr[0])
	}

	var mediaUrn string
	var value []byte

	for k, v := range argMap {
		key, ok := k.(string)
		if !ok {
			continue
		}
		switch key {
		case "media_urn":
			if s, ok := v.(string); ok {
				mediaUrn = s
			}
		case "value":
			if b, ok := v.([]byte); ok {
				value = b
			}
		}
	}

	if mediaUrn != "media:pdf;bytes" {
		t.Errorf("Media URN should match cap in_spec, got: %s", mediaUrn)
	}
	if string(value) != string(pdfContent) {
		t.Errorf("Binary content should be preserved exactly, got %d bytes, expected %d bytes", len(value), len(pdfContent))
	}
}

// TEST363: CBOR mode with chunked content - send file content streaming as chunks
func Test363CBORModeChunkedContent(t *testing.T) {
	pdfContent := make([]byte, 10000) // 10KB of data
	for i := range pdfContent {
		pdfContent[i] = 0xAA
	}

	var receivedData []byte
	receivedChan := make(chan []byte, 1)

	handler := func(frames <-chan Frame, emitter StreamEmitter, peer PeerInvoker) error {
		// TRUE STREAMING: Relay frames and verify
		var total []byte
		for frame := range frames {
			if frame.FrameType == FrameTypeChunk {
				if frame.Payload != nil {
					total = append(total, frame.Payload...)
					if err := emitter.EmitCbor(frame.Payload); err != nil {
						return err
					}
				}
			}
		}

		// Verify what we received
		var cborVal interface{}
		if err := cborlib.Unmarshal(total, &cborVal); err != nil {
			return err
		}

		if arr, ok := cborVal.([]interface{}); ok {
			if argMap, ok := arr[0].(map[interface{}]interface{}); ok {
				for k, v := range argMap {
					if key, ok := k.(string); ok && key == "value" {
						if data, ok := v.([]byte); ok {
							receivedChan <- data
						}
					}
				}
			}
		}
		return nil
	}

	capDef := createTestCap(
		`cap:in="media:pdf;bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{
			{
				MediaUrn: "media:pdf;bytes",
				Required: true,
				Sources: []cap.ArgSource{
					stdinSource("media:pdf;bytes"),
				},
			},
		},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}
	runtime.Register(capDef.UrnString(), handler)

	// Build CBOR payload
	args := []cap.CapArgumentValue{
		{
			MediaUrn: "media:pdf;bytes",
			Value:    pdfContent,
		},
	}
	var payloadBytes []byte
	cborArgs := make([]interface{}, len(args))
	for i, arg := range args {
		cborArgs[i] = map[string]interface{}{
			"media_urn": arg.MediaUrn,
			"value":     arg.Value,
		}
	}
	payloadBytes, err = cborlib.Marshal(cborArgs)
	if err != nil {
		t.Fatalf("Failed to marshal CBOR: %v", err)
	}

	// Simulate streaming: chunk payload and send via channel
	handlerFunc := runtime.FindHandler(capDef.UrnString())
	if handlerFunc == nil {
		t.Fatal("Handler not found")
	}

	noPeer := &noPeerInvoker{}
	emitter := &mockStreamEmitter{}

	frameChan := make(chan Frame, 100)
	const maxChunk = 262144
	requestID := NewMessageIdDefault()
	streamID := "test-stream"

	// Send STREAM_START
	frameChan <- *NewStreamStart(requestID, streamID, "media:bytes")

	// Send CHUNK frames
	offset := 0
	seq := uint64(0)
	for offset < len(payloadBytes) {
		chunkSize := len(payloadBytes) - offset
		if chunkSize > maxChunk {
			chunkSize = maxChunk
		}
		chunkData := payloadBytes[offset : offset+chunkSize]
		chunkIndex := seq
		checksum := ComputeChecksum(chunkData)
		frameChan <- *NewChunk(requestID, streamID, seq, chunkData, chunkIndex, checksum)
		offset += chunkSize
		seq++
	}

	// Send STREAM_END and END
	frameChan <- *NewStreamEnd(requestID, streamID)
	frameChan <- *NewEnd(requestID, nil)
	close(frameChan)

	// Run handler in goroutine
	go func() {
		if err := handlerFunc(frameChan, emitter, noPeer); err != nil {
			t.Errorf("Handler failed: %v", err)
		}
	}()

	// Wait for result
	select {
	case receivedData = <-receivedChan:
	case <-time.After(5 * time.Second):
		t.Fatal("Timeout waiting for handler response")
	}

	if string(receivedData) != string(pdfContent) {
		t.Errorf("Handler should receive chunked content, got %d bytes, expected %d bytes", len(receivedData), len(pdfContent))
	}
}

// TEST364: CBOR mode with file path - send file path in CBOR arguments (auto-conversion)
func Test364CBORModeFilePath(t *testing.T) {
	tempFile := filepath.Join(os.TempDir(), "test364.pdf")
	pdfContent := []byte("PDF content for CBOR file path test")
	if err := os.WriteFile(tempFile, pdfContent, 0644); err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}
	defer os.Remove(tempFile)

	// Build CBOR arguments with file-path URN
	args := []cap.CapArgumentValue{
		{
			MediaUrn: "media:file-path;textable;form=scalar",
			Value:    []byte(tempFile),
		},
	}
	var payload []byte
	cborArgs := make([]interface{}, len(args))
	for i, arg := range args {
		cborArgs[i] = map[string]interface{}{
			"media_urn": arg.MediaUrn,
			"value":     arg.Value,
		}
	}
	payload, err := cborlib.Marshal(cborArgs)
	if err != nil {
		t.Fatalf("Failed to marshal CBOR: %v", err)
	}

	// Verify the CBOR structure is correct
	var decoded []interface{}
	if err := cborlib.Unmarshal(payload, &decoded); err != nil {
		t.Fatalf("Failed to unmarshal CBOR: %v", err)
	}

	if len(decoded) != 1 {
		t.Fatalf("Expected 1 argument, got: %d", len(decoded))
	}

	argMap, ok := decoded[0].(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected map, got: %T", decoded[0])
	}

	mediaUrn, _ := argMap["media_urn"].(string)
	value, _ := argMap["value"].([]byte)

	if mediaUrn != "media:file-path;textable;form=scalar" {
		t.Errorf("Expected media:file-path URN, got: %s", mediaUrn)
	}
	if string(value) != tempFile {
		t.Errorf("Expected file path as value, got: %s", string(value))
	}
}

// TEST395: Small payload (< max_chunk) produces correct CBOR arguments
func Test395BuildPayloadSmall(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	data := []byte("small payload")
	reader := bytes.NewReader(data)

	payload, err := runtime.buildPayloadFromStreamingReader(capDef, reader, DefaultLimits().MaxChunk)
	if err != nil {
		t.Fatalf("buildPayloadFromStreamingReader failed: %v", err)
	}

	// Verify CBOR structure
	var cborVal interface{}
	if err := cborlib.Unmarshal(payload, &cborVal); err != nil {
		t.Fatalf("Failed to parse CBOR: %v", err)
	}

	arr, ok := cborVal.([]interface{})
	if !ok || len(arr) != 1 {
		t.Fatalf("Expected array with one argument, got: %T %v", cborVal, cborVal)
	}

	argMap, ok := arr[0].(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected map, got: %T", arr[0])
	}

	valueBytes, ok := argMap["value"].([]byte)
	if !ok {
		t.Fatalf("Expected bytes for value, got: %T", argMap["value"])
	}

	if !bytes.Equal(valueBytes, data) {
		t.Errorf("Payload bytes should match, expected: %v, got: %v", data, valueBytes)
	}
}

// TEST396: Large payload (> max_chunk) accumulates across chunks correctly
func Test396BuildPayloadLarge(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	// Use small max_chunk to force multi-chunk
	data := make([]byte, 1000)
	for i := 0; i < 1000; i++ {
		data[i] = byte(i % 256)
	}
	reader := bytes.NewReader(data)

	payload, err := runtime.buildPayloadFromStreamingReader(capDef, reader, 100)
	if err != nil {
		t.Fatalf("buildPayloadFromStreamingReader failed: %v", err)
	}

	var cborVal interface{}
	if err := cborlib.Unmarshal(payload, &cborVal); err != nil {
		t.Fatalf("Failed to parse CBOR: %v", err)
	}

	arr := cborVal.([]interface{})
	argMap := arr[0].(map[interface{}]interface{})
	valueBytes := argMap["value"].([]byte)

	if len(valueBytes) != 1000 {
		t.Errorf("All bytes should be accumulated, expected: 1000, got: %d", len(valueBytes))
	}
	if !bytes.Equal(valueBytes, data) {
		t.Errorf("Data should match exactly")
	}
}

// TEST397: Empty reader produces valid empty CBOR arguments
func Test397BuildPayloadEmpty(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	reader := bytes.NewReader([]byte{})

	payload, err := runtime.buildPayloadFromStreamingReader(capDef, reader, DefaultLimits().MaxChunk)
	if err != nil {
		t.Fatalf("buildPayloadFromStreamingReader failed: %v", err)
	}

	var cborVal interface{}
	if err := cborlib.Unmarshal(payload, &cborVal); err != nil {
		t.Fatalf("Failed to parse CBOR: %v", err)
	}

	arr := cborVal.([]interface{})
	argMap := arr[0].(map[interface{}]interface{})
	valueBytes := argMap["value"].([]byte)

	if len(valueBytes) != 0 {
		t.Errorf("Empty reader should produce empty bytes, got: %d bytes", len(valueBytes))
	}
}

// errorReader is a reader that always returns an error
type errorReader struct{}

func (e *errorReader) Read(p []byte) (n int, err error) {
	return 0, fmt.Errorf("simulated read error")
}

// TEST398: IO error from reader propagates as error
func Test398BuildPayloadIOError(t *testing.T) {
	capDef := createTestCap(
		`cap:in="media:bytes";op=process;out="media:void"`,
		"Process",
		"process",
		[]cap.CapArg{},
	)

	manifest := createTestManifest("TestPlugin", "1.0.0", "Test", []*cap.Cap{capDef})
	runtime, err := NewPluginRuntimeWithManifest(manifest)
	if err != nil {
		t.Fatalf("Failed to create runtime: %v", err)
	}

	reader := &errorReader{}

	_, err = runtime.buildPayloadFromStreamingReader(capDef, reader, DefaultLimits().MaxChunk)
	if err == nil {
		t.Fatal("IO error should propagate")
	}
	if !strings.Contains(err.Error(), "simulated read error") {
		t.Errorf("Expected error to contain 'simulated read error', got: %s", err.Error())
	}
}
